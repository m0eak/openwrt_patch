--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -49,6 +49,8 @@
 #include <net/slhc_vj.h>
 #include <linux/atomic.h>
 #include <linux/refcount.h>
+#include <linux/if_pppox.h>
+#include <linux/notifier.h>
 
 #include <linux/nsproxy.h>
 #include <net/net_namespace.h>
@@ -2985,6 +2987,190 @@
 	return name;
 }
 
+/* Call this to obtain the underlying protocol of the PPP channel */
+int ppp_channel_get_protocol(struct ppp_channel *chan)
+{
+	if (!chan || !chan->ops || !chan->ops->get_channel_protocol)
+		return 0;
+
+	return chan->ops->get_channel_protocol(chan);
+}
+EXPORT_SYMBOL(ppp_channel_get_protocol);
+
+/* Call this to get channel protocol version */
+int ppp_channel_get_proto_version(struct ppp_channel *chan)
+{
+	if (!chan || !chan->ops || !chan->ops->get_channel_protocol_ver)
+		return 0;
+
+	return chan->ops->get_channel_protocol_ver(chan);
+}
+EXPORT_SYMBOL(ppp_channel_get_proto_version);
+
+/* Update PPP interface statistics */
+void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+		      unsigned long rx_bytes, unsigned long tx_packets,
+		      unsigned long tx_bytes, unsigned long rx_errors,
+		      unsigned long tx_errors, unsigned long rx_dropped,
+		      unsigned long tx_dropped)
+{
+	struct pcpu_sw_netstats *tstats;
+
+	if (!dev)
+		return;
+
+	if (tx_packets || tx_bytes)
+		dev_sw_netstats_tx_add(dev, tx_packets, tx_bytes);
+
+	if (rx_packets || rx_bytes) {
+		tstats = this_cpu_ptr(dev->tstats);
+		u64_stats_update_begin(&tstats->syncp);
+		u64_stats_add(&tstats->rx_packets, rx_packets);
+		u64_stats_add(&tstats->rx_bytes, rx_bytes);
+		u64_stats_update_end(&tstats->syncp);
+	}
+
+	dev->stats.rx_errors += rx_errors;
+	dev->stats.tx_errors += tx_errors;
+	dev->stats.rx_dropped += rx_dropped;
+	dev->stats.tx_dropped += tx_dropped;
+}
+EXPORT_SYMBOL(ppp_update_stats);
+
+/* Returns true if Compression is enabled on PPP device */
+bool ppp_is_cp_enabled(struct net_device *dev)
+{
+	struct ppp *ppp;
+	bool ret = false;
+
+	if (!dev || dev->type != ARPHRD_PPP)
+		return false;
+
+	ppp = netdev_priv(dev);
+	ppp_lock(ppp);
+	ret = !!(ppp->flags & SC_CCP_UP);
+	ppp_unlock(ppp);
+
+	return ret;
+}
+EXPORT_SYMBOL(ppp_is_cp_enabled);
+
+/* Test if the ppp device is a multi-link ppp device */
+int __ppp_is_multilink(struct net_device *dev)
+{
+	struct ppp *ppp;
+
+	if (!dev || dev->type != ARPHRD_PPP)
+		return 0;
+
+	ppp = netdev_priv(dev);
+	return !!(ppp->flags & SC_MULTILINK);
+}
+EXPORT_SYMBOL(__ppp_is_multilink);
+
+int ppp_is_multilink(struct net_device *dev)
+{
+	struct ppp *ppp;
+	int ret = 0;
+
+	if (!dev || dev->type != ARPHRD_PPP)
+		return 0;
+
+	ppp = netdev_priv(dev);
+	ppp_lock(ppp);
+	ret = !!(ppp->flags & SC_MULTILINK);
+	ppp_unlock(ppp);
+
+	return ret;
+}
+EXPORT_SYMBOL(ppp_is_multilink);
+
+/* Hold PPP channels for the PPP device */
+int __ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[],
+			unsigned int chan_sz)
+{
+	struct ppp *ppp;
+	struct channel *pch;
+	unsigned int count = 0;
+
+	if (!dev || dev->type != ARPHRD_PPP)
+		return 0;
+
+	ppp = netdev_priv(dev);
+	ppp_lock(ppp);
+	list_for_each_entry(pch, &ppp->channels, clist) {
+		struct ppp_channel *chan = READ_ONCE(pch->chan);
+
+		if (!chan)
+			continue;
+		if (count >= chan_sz)
+			break;
+
+		channels[count++] = chan;
+		if (chan->ops && chan->ops->hold)
+			chan->ops->hold(chan);
+	}
+	ppp_unlock(ppp);
+
+	return count;
+}
+EXPORT_SYMBOL(__ppp_hold_channels);
+
+int ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[],
+		      unsigned int chan_sz)
+{
+	return __ppp_hold_channels(dev, channels, chan_sz);
+}
+EXPORT_SYMBOL(ppp_hold_channels);
+
+/* Release PPP channels */
+void ppp_release_channels(struct ppp_channel *channels[],
+			  unsigned int chan_sz)
+{
+	unsigned int i;
+
+	for (i = 0; i < chan_sz; i++) {
+		struct ppp_channel *chan = channels[i];
+
+		if (!chan)
+			continue;
+		if (chan->ops && chan->ops->release)
+			chan->ops->release(chan);
+	}
+}
+EXPORT_SYMBOL(ppp_release_channels);
+
+/* Test if ppp xmit lock is locked */
+bool ppp_is_xmit_locked(struct net_device *dev)
+{
+	struct ppp *ppp;
+
+	if (!dev || dev->type != ARPHRD_PPP)
+		return false;
+
+	ppp = netdev_priv(dev);
+	return spin_is_locked(&ppp->wlock);
+}
+EXPORT_SYMBOL(ppp_is_xmit_locked);
+
+/*
+ * Registration/Unregistration methods
+ * for PPP channel connect and disconnect event notifications.
+ */
+RAW_NOTIFIER_HEAD(ppp_channel_connection_notifier_list);
+
+void ppp_channel_connection_register_notify(struct notifier_block *nb)
+{
+	raw_notifier_chain_register(&ppp_channel_connection_notifier_list, nb);
+}
+EXPORT_SYMBOL_GPL(ppp_channel_connection_register_notify);
+
+void ppp_channel_connection_unregister_notify(struct notifier_block *nb)
+{
+	raw_notifier_chain_unregister(&ppp_channel_connection_notifier_list, nb);
+}
+EXPORT_SYMBOL_GPL(ppp_channel_connection_unregister_notify);
+
 
 /*
  * Disconnect a channel from the generic layer.
@@ -3496,6 +3682,8 @@
 	struct ppp_net *pn;
 	int ret = -ENXIO;
 	int hdrlen;
+	struct net_device *dev = NULL;
+	bool notify = false;
 
 	pn = ppp_pernet(pch->chan_net);
 
@@ -3532,13 +3720,18 @@
 	++ppp->n_channels;
 	rcu_assign_pointer(pch->ppp, ppp);
 	refcount_inc(&ppp->file.refcnt);
+	dev = ppp->dev;
 	ppp_unlock(ppp);
 	ret = 0;
+	notify = true;
 
  outl:
 	spin_unlock(&pch->upl);
  out:
 	mutex_unlock(&pn->all_ppp_mutex);
+	if (notify)
+		raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
+					PPP_CHANNEL_CONNECT, dev);
 	return ret;
 }
 
@@ -3550,6 +3743,7 @@
 {
 	struct ppp *ppp;
 	int err = -EINVAL;
+	struct net_device *dev = NULL;
 
 	spin_lock(&pch->upl);
 	ppp = rcu_replace_pointer(pch->ppp, NULL, lockdep_is_held(&pch->upl));
@@ -3562,6 +3756,9 @@
 			wake_up_interruptible(&ppp->file.rwait);
 		ppp_unlock(ppp);
 		synchronize_net();
+		dev = ppp->dev;
+		raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
+					PPP_CHANNEL_DISCONNECT, dev);
 		if (refcount_dec_and_test(&ppp->file.refcnt))
 			ppp_destroy_interface(ppp);
 		err = 0;
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -18,8 +18,10 @@
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/poll.h>
+#include <linux/notifier.h>
 #include <net/net_namespace.h>
 
+struct net_device;
 struct net_device_path;
 struct net_device_path_ctx;
 struct ppp_channel;
@@ -33,6 +35,13 @@
 	int	(*fill_forward_path)(struct net_device_path_ctx *,
 				     struct net_device_path *,
 				     const struct ppp_channel *);
+	/* Get underlying channel protocol */
+	int	(*get_channel_protocol)(struct ppp_channel *);
+	/* Get channel protocol version */
+	int	(*get_channel_protocol_ver)(struct ppp_channel *);
+	/* Hold/release channel */
+	void	(*hold)(struct ppp_channel *);
+	void	(*release)(struct ppp_channel *);
 };
 
 struct ppp_channel {
@@ -75,6 +84,46 @@
 /* Get the device name associated with a channel, or NULL if none */
 extern char *ppp_dev_name(struct ppp_channel *);
 
+/* PPP channel connection event types */
+#define PPP_CHANNEL_DISCONNECT	0
+#define PPP_CHANNEL_CONNECT	1
+
+/* Register the PPP channel connect notifier */
+extern void ppp_channel_connection_register_notify(struct notifier_block *nb);
+
+/* Unregister the PPP channel connect notifier */
+extern void ppp_channel_connection_unregister_notify(struct notifier_block *nb);
+
+/* Call this to obtain the underlying protocol of the PPP channel, e.g. PX_PROTO_OE */
+extern int ppp_channel_get_protocol(struct ppp_channel *);
+
+/* Call this to get channel protocol version */
+extern int ppp_channel_get_proto_version(struct ppp_channel *);
+
+/* Update PPP interface statistics */
+extern void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+			     unsigned long rx_bytes, unsigned long tx_packets,
+			     unsigned long tx_bytes, unsigned long rx_errors,
+			     unsigned long tx_errors, unsigned long rx_dropped,
+			     unsigned long tx_dropped);
+
+/* Returns true if Compression is enabled on PPP device */
+extern bool ppp_is_cp_enabled(struct net_device *dev);
+
+/* Test if the ppp device is a multi-link ppp device */
+extern int ppp_is_multilink(struct net_device *dev);
+extern int __ppp_is_multilink(struct net_device *dev);
+
+/* Hold PPP channels for the PPP device */
+extern int ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[], unsigned int chan_sz);
+extern int __ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[], unsigned int chan_sz);
+
+/* Release PPP channels */
+extern void ppp_release_channels(struct ppp_channel *channels[], unsigned int chan_sz);
+
+/* Test if ppp xmit lock is locked */
+extern bool ppp_is_xmit_locked(struct net_device *dev);
+
 /*
  * SMP locking notes:
  * The channel code must ensure that when it calls ppp_unregister_channel,
