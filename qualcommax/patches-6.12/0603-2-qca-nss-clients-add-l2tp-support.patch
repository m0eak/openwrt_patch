--- a/include/linux/if_pppol2tp.h
+++ b/include/linux/if_pppol2tp.h
@@ -12,4 +12,30 @@
 #include <linux/in6.h>
 #include <uapi/linux/if_pppol2tp.h>
 
+/* QCA NSS ECM support - Start */
+/*
+ * Holds L2TP channel info
+ */
+struct pppol2tp_common_addr {
+	int tunnel_version;				/* v2 or v3 */
+	__u32 local_tunnel_id, remote_tunnel_id;	/* tunnel id */
+	__u32 local_session_id, remote_session_id;	/* session id */
+	struct sockaddr_in local_addr, remote_addr; /* ip address and port */
+};
+
+/*
+ * L2TP channel operations
+ */
+struct pppol2tp_channel_ops {
+	struct ppp_channel_ops ops; /* ppp channel ops */
+};
+
+/*
+ * exported function which calls pppol2tp channel's get addressing
+ * function
+ */
+extern int pppol2tp_channel_addressing_get(struct ppp_channel *,
+			   struct pppol2tp_common_addr *);
+/* QCA NSS ECM support - End */
+
 #endif
--- a/net/l2tp/l2tp_ppp.c
+++ b/net/l2tp/l2tp_ppp.c
@@ -123,8 +123,17 @@
 
 static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);
 
+static int pppol2tp_get_channel_protocol(struct ppp_channel *);
+static int pppol2tp_get_channel_protocol_ver(struct ppp_channel *);
+static void pppol2tp_hold_chan(struct ppp_channel *);
+static void pppol2tp_release_chan(struct ppp_channel *);
+
 static const struct ppp_channel_ops pppol2tp_chan_ops = {
 	.start_xmit =  pppol2tp_xmit,
+	.get_channel_protocol = pppol2tp_get_channel_protocol,
+	.get_channel_protocol_ver = pppol2tp_get_channel_protocol_ver,
+	.hold = pppol2tp_hold_chan,
+	.release = pppol2tp_release_chan,
 };
 
 static const struct proto_ops pppol2tp_ops;
@@ -250,6 +259,8 @@
 			    size_t total_len)
 {
 	struct sock *sk = sock->sk;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct ppp_channel *chan = &po->chan;
 	struct sk_buff *skb;
 	int error;
 	struct l2tp_session *session;
@@ -289,6 +300,13 @@
 	/* Add PPP header */
 	skb->data[0] = PPP_ALLSTATIONS;
 	skb->data[1] = PPP_UI;
+
+	/* QCA NSS ECM support - start */
+	/* set incoming interface as the ppp interface */
+	if ((skb->protocol == htons(ETH_P_IP)) ||
+	    (skb->protocol == htons(ETH_P_IPV6)))
+		skb->skb_iif = ppp_dev_index(chan);
+	/* QCA NSS ECM support - End */
 	skb_put(skb, 2);
 
 	/* Copy user data into skb */
@@ -357,6 +375,13 @@
 	skb->data[0] = PPP_ALLSTATIONS;
 	skb->data[1] = PPP_UI;
 
+	/* QCA NSS ECM support - start */
+	/* set incoming interface as the ppp interface */
+	if ((skb->protocol == htons(ETH_P_IP)) ||
+	    (skb->protocol == htons(ETH_P_IPV6)))
+		skb->skb_iif = ppp_dev_index(chan);
+	/* QCA NSS ECM support - End */
+
 	local_bh_disable();
 	l2tp_xmit_skb(session, skb);
 	local_bh_enable();
@@ -373,6 +398,93 @@
 	return 1;
 }
 
+/* pppol2tp_hold_chan() */
+static void pppol2tp_hold_chan(struct ppp_channel *chan)
+{
+	struct sock *sk = (struct sock *)chan->private;
+
+	sock_hold(sk);
+}
+
+/* pppol2tp_release_chan() */
+static void pppol2tp_release_chan(struct ppp_channel *chan)
+{
+	struct sock *sk = (struct sock *)chan->private;
+
+	sock_put(sk);
+}
+
+/* pppol2tp_get_channel_protocol()
+ *     Return the protocol type of the L2TP over PPP protocol
+ */
+static int pppol2tp_get_channel_protocol(struct ppp_channel *chan)
+{
+	return PX_PROTO_OL2TP;
+}
+
+/* pppol2tp_get_channel_protocol_ver()
+ *     Return the L2TP tunnel version
+ */
+static int pppol2tp_get_channel_protocol_ver(struct ppp_channel *chan)
+{
+	struct sock *sk = (struct sock *)chan->private;
+	struct l2tp_session *session;
+	struct l2tp_tunnel *tunnel;
+
+	session = pppol2tp_sock_to_session(sk);
+	if (!session)
+		return 0;
+
+	tunnel = session->tunnel;
+	if (!tunnel)
+		return 0;
+
+	return tunnel->version;
+}
+
+/* pppol2tp_channel_addressing_get()
+ *     Return the channel addressing information.
+ */
+int pppol2tp_channel_addressing_get(struct ppp_channel *chan,
+				    struct pppol2tp_common_addr *addressing)
+{
+	struct sock *sk;
+	struct l2tp_session *session;
+	struct l2tp_tunnel *tunnel;
+	struct inet_sock *inet;
+
+	if (!chan || !addressing)
+		return -EINVAL;
+
+	sk = (struct sock *)chan->private;
+	session = pppol2tp_sock_to_session(sk);
+	if (!session)
+		return -ENOTCONN;
+
+	tunnel = session->tunnel;
+	if (!tunnel || !tunnel->sock)
+		return -ENOTCONN;
+
+	inet = inet_sk(tunnel->sock);
+
+	memset(addressing, 0, sizeof(*addressing));
+	addressing->tunnel_version = tunnel->version;
+	addressing->local_tunnel_id = tunnel->tunnel_id;
+	addressing->remote_tunnel_id = tunnel->peer_tunnel_id;
+	addressing->local_session_id = session->session_id;
+	addressing->remote_session_id = session->peer_session_id;
+
+	addressing->local_addr.sin_family = AF_INET;
+	addressing->local_addr.sin_port = inet->inet_sport;
+	addressing->local_addr.sin_addr.s_addr = inet->inet_saddr;
+	addressing->remote_addr.sin_family = AF_INET;
+	addressing->remote_addr.sin_port = inet->inet_dport;
+	addressing->remote_addr.sin_addr.s_addr = inet->inet_daddr;
+
+	return 0;
+}
+EXPORT_SYMBOL(pppol2tp_channel_addressing_get);
+
 /*****************************************************************************
  * Session (and tunnel control) socket create/destroy.
  *****************************************************************************/
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@ -622,6 +622,30 @@
 }
 EXPORT_SYMBOL_GPL(l2tp_session_register);
 
+void l2tp_stats_update(struct l2tp_tunnel *tunnel,
+		       struct l2tp_session *session,
+		       struct l2tp_stats *stats)
+{
+	atomic_long_add(atomic_long_read(&stats->rx_packets),
+			&tunnel->stats.rx_packets);
+	atomic_long_add(atomic_long_read(&stats->rx_bytes),
+			&tunnel->stats.rx_bytes);
+	atomic_long_add(atomic_long_read(&stats->tx_packets),
+			&tunnel->stats.tx_packets);
+	atomic_long_add(atomic_long_read(&stats->tx_bytes),
+			&tunnel->stats.tx_bytes);
+
+	atomic_long_add(atomic_long_read(&stats->rx_packets),
+			&session->stats.rx_packets);
+	atomic_long_add(atomic_long_read(&stats->rx_bytes),
+			&session->stats.rx_bytes);
+	atomic_long_add(atomic_long_read(&stats->tx_packets),
+			&session->stats.tx_packets);
+	atomic_long_add(atomic_long_read(&stats->tx_bytes),
+			&session->stats.tx_bytes);
+}
+EXPORT_SYMBOL_GPL(l2tp_stats_update);
+
 /*****************************************************************************
  * Receive data handling
  *****************************************************************************/
--- a/net/l2tp/l2tp_core.h
+++ b/net/l2tp/l2tp_core.h
@@ -228,6 +228,10 @@
 struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,
 						const char *ifname);
 
+void l2tp_stats_update(struct l2tp_tunnel *tunnel,
+		       struct l2tp_session *session,
+		       struct l2tp_stats *stats);
+
 /* Tunnel and session lifetime management.
  * Creation of a new instance is a two-step process: create, then register.
  * Destruction is triggered using the *_delete functions, and completes asynchronously.
